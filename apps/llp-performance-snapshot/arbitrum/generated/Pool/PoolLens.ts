// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class PoolLens__getPoolInfoResultInfoStruct extends ethereum.Tuple {
  get minValue(): BigInt {
    return this[0].toBigInt();
  }

  get maxValue(): BigInt {
    return this[1].toBigInt();
  }

  get tranchesMinValue(): Array<BigInt> {
    return this[2].toBigIntArray();
  }

  get tranchesMaxValue(): Array<BigInt> {
    return this[3].toBigIntArray();
  }
}

export class PoolLens__getPositionResultResultStruct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get key(): Bytes {
    return this[1].toBytes();
  }

  get indexToken(): Address {
    return this[2].toAddress();
  }

  get side(): i32 {
    return this[3].toI32();
  }

  get collateralToken(): Address {
    return this[4].toAddress();
  }

  get hasProfit(): boolean {
    return this[5].toBoolean();
  }

  get size(): BigInt {
    return this[6].toBigInt();
  }

  get collateralValue(): BigInt {
    return this[7].toBigInt();
  }

  get entryPrice(): BigInt {
    return this[8].toBigInt();
  }

  get pnl(): BigInt {
    return this[9].toBigInt();
  }

  get reserveAmount(): BigInt {
    return this[10].toBigInt();
  }

  get borrowIndex(): BigInt {
    return this[11].toBigInt();
  }

  get revision(): BigInt {
    return this[12].toBigInt();
  }
}

export class PoolLens__getUserPositionsResultValue0Struct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get key(): Bytes {
    return this[1].toBytes();
  }

  get indexToken(): Address {
    return this[2].toAddress();
  }

  get side(): i32 {
    return this[3].toI32();
  }

  get collateralToken(): Address {
    return this[4].toAddress();
  }

  get hasProfit(): boolean {
    return this[5].toBoolean();
  }

  get size(): BigInt {
    return this[6].toBigInt();
  }

  get collateralValue(): BigInt {
    return this[7].toBigInt();
  }

  get entryPrice(): BigInt {
    return this[8].toBigInt();
  }

  get pnl(): BigInt {
    return this[9].toBigInt();
  }

  get reserveAmount(): BigInt {
    return this[10].toBigInt();
  }

  get borrowIndex(): BigInt {
    return this[11].toBigInt();
  }

  get revision(): BigInt {
    return this[12].toBigInt();
  }
}

export class PoolLens__poolAssetsResultPoolAssetStruct extends ethereum.Tuple {
  get poolAmount(): BigInt {
    return this[0].toBigInt();
  }

  get reservedAmount(): BigInt {
    return this[1].toBigInt();
  }

  get feeReserve(): BigInt {
    return this[2].toBigInt();
  }

  get guaranteedValue(): BigInt {
    return this[3].toBigInt();
  }

  get totalShortSize(): BigInt {
    return this[4].toBigInt();
  }

  get averageShortPrice(): BigInt {
    return this[5].toBigInt();
  }

  get poolBalance(): BigInt {
    return this[6].toBigInt();
  }

  get lastAccrualTimestamp(): BigInt {
    return this[7].toBigInt();
  }

  get borrowIndex(): BigInt {
    return this[8].toBigInt();
  }
}

export class PoolLens extends ethereum.SmartContract {
  static bind(address: Address): PoolLens {
    return new PoolLens("PoolLens", address);
  }

  getAssetAum(_tranche: Address, _token: Address, _max: boolean): BigInt {
    let result = super.call(
      "getAssetAum",
      "getAssetAum(address,address,bool):(uint256)",
      [
        ethereum.Value.fromAddress(_tranche),
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromBoolean(_max)
      ]
    );

    return result[0].toBigInt();
  }

  try_getAssetAum(
    _tranche: Address,
    _token: Address,
    _max: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAssetAum",
      "getAssetAum(address,address,bool):(uint256)",
      [
        ethereum.Value.fromAddress(_tranche),
        ethereum.Value.fromAddress(_token),
        ethereum.Value.fromBoolean(_max)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getAssetPoolAum(_token: Address, _max: boolean): BigInt {
    let result = super.call(
      "getAssetPoolAum",
      "getAssetPoolAum(address,bool):(uint256)",
      [ethereum.Value.fromAddress(_token), ethereum.Value.fromBoolean(_max)]
    );

    return result[0].toBigInt();
  }

  try_getAssetPoolAum(
    _token: Address,
    _max: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getAssetPoolAum",
      "getAssetPoolAum(address,bool):(uint256)",
      [ethereum.Value.fromAddress(_token), ethereum.Value.fromBoolean(_max)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getLpPrice(_tranche: Address): BigInt {
    let result = super.call("getLpPrice", "getLpPrice(address):(uint256)", [
      ethereum.Value.fromAddress(_tranche)
    ]);

    return result[0].toBigInt();
  }

  try_getLpPrice(_tranche: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getLpPrice", "getLpPrice(address):(uint256)", [
      ethereum.Value.fromAddress(_tranche)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolInfo(): PoolLens__getPoolInfoResultInfoStruct {
    let result = super.call(
      "getPoolInfo",
      "getPoolInfo():((uint256,uint256,uint256[],uint256[]))",
      []
    );

    return changetype<PoolLens__getPoolInfoResultInfoStruct>(
      result[0].toTuple()
    );
  }

  try_getPoolInfo(): ethereum.CallResult<
    PoolLens__getPoolInfoResultInfoStruct
  > {
    let result = super.tryCall(
      "getPoolInfo",
      "getPoolInfo():((uint256,uint256,uint256[],uint256[]))",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<PoolLens__getPoolInfoResultInfoStruct>(value[0].toTuple())
    );
  }

  getPoolValue(): BigInt {
    let result = super.call("getPoolValue", "getPoolValue():(uint256)", []);

    return result[0].toBigInt();
  }

  try_getPoolValue(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getPoolValue", "getPoolValue():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPoolValue1(_max: boolean): BigInt {
    let result = super.call("getPoolValue", "getPoolValue(bool):(uint256)", [
      ethereum.Value.fromBoolean(_max)
    ]);

    return result[0].toBigInt();
  }

  try_getPoolValue1(_max: boolean): ethereum.CallResult<BigInt> {
    let result = super.tryCall("getPoolValue", "getPoolValue(bool):(uint256)", [
      ethereum.Value.fromBoolean(_max)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getPosition(
    _owner: Address,
    _indexToken: Address,
    _collateralToken: Address,
    _side: i32
  ): PoolLens__getPositionResultResultStruct {
    let result = super.call(
      "getPosition",
      "getPosition(address,address,address,uint8):((address,bytes32,address,uint8,address,bool,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [
        ethereum.Value.fromAddress(_owner),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_side))
      ]
    );

    return changetype<PoolLens__getPositionResultResultStruct>(
      result[0].toTuple()
    );
  }

  try_getPosition(
    _owner: Address,
    _indexToken: Address,
    _collateralToken: Address,
    _side: i32
  ): ethereum.CallResult<PoolLens__getPositionResultResultStruct> {
    let result = super.tryCall(
      "getPosition",
      "getPosition(address,address,address,uint8):((address,bytes32,address,uint8,address,bool,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [
        ethereum.Value.fromAddress(_owner),
        ethereum.Value.fromAddress(_indexToken),
        ethereum.Value.fromAddress(_collateralToken),
        ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(_side))
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<PoolLens__getPositionResultResultStruct>(value[0].toTuple())
    );
  }

  getTrancheValue(_tranche: Address): BigInt {
    let result = super.call(
      "getTrancheValue",
      "getTrancheValue(address):(uint256)",
      [ethereum.Value.fromAddress(_tranche)]
    );

    return result[0].toBigInt();
  }

  try_getTrancheValue(_tranche: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTrancheValue",
      "getTrancheValue(address):(uint256)",
      [ethereum.Value.fromAddress(_tranche)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getTrancheValue1(_tranche: Address, _max: boolean): BigInt {
    let result = super.call(
      "getTrancheValue",
      "getTrancheValue(address,bool):(uint256)",
      [ethereum.Value.fromAddress(_tranche), ethereum.Value.fromBoolean(_max)]
    );

    return result[0].toBigInt();
  }

  try_getTrancheValue1(
    _tranche: Address,
    _max: boolean
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "getTrancheValue",
      "getTrancheValue(address,bool):(uint256)",
      [ethereum.Value.fromAddress(_tranche), ethereum.Value.fromBoolean(_max)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getUserPositions(
    _user: Address
  ): Array<PoolLens__getUserPositionsResultValue0Struct> {
    let result = super.call(
      "getUserPositions",
      "getUserPositions(address):((address,bytes32,address,uint8,address,bool,uint256,uint256,uint256,uint256,uint256,uint256,uint256)[])",
      [ethereum.Value.fromAddress(_user)]
    );

    return result[0].toTupleArray<
      PoolLens__getUserPositionsResultValue0Struct
    >();
  }

  try_getUserPositions(
    _user: Address
  ): ethereum.CallResult<Array<PoolLens__getUserPositionsResultValue0Struct>> {
    let result = super.tryCall(
      "getUserPositions",
      "getUserPositions(address):((address,bytes32,address,uint8,address,bool,uint256,uint256,uint256,uint256,uint256,uint256,uint256)[])",
      [ethereum.Value.fromAddress(_user)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      value[0].toTupleArray<PoolLens__getUserPositionsResultValue0Struct>()
    );
  }

  pool(): Address {
    let result = super.call("pool", "pool():(address)", []);

    return result[0].toAddress();
  }

  try_pool(): ethereum.CallResult<Address> {
    let result = super.tryCall("pool", "pool():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  poolAssets(_token: Address): PoolLens__poolAssetsResultPoolAssetStruct {
    let result = super.call(
      "poolAssets",
      "poolAssets(address):((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [ethereum.Value.fromAddress(_token)]
    );

    return changetype<PoolLens__poolAssetsResultPoolAssetStruct>(
      result[0].toTuple()
    );
  }

  try_poolAssets(
    _token: Address
  ): ethereum.CallResult<PoolLens__poolAssetsResultPoolAssetStruct> {
    let result = super.tryCall(
      "poolAssets",
      "poolAssets(address):((uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256))",
      [ethereum.Value.fromAddress(_token)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<PoolLens__poolAssetsResultPoolAssetStruct>(value[0].toTuple())
    );
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get _pool(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}
